local json = require('json')
require('utils')
require('class')
require('ap_mcm')

AP = class()

require('ap_client')

AP.INSTANCE = nil

AP.MOD_NAME = "AP Integration"

AP.ITEM_IMPLS = {
    [78000] = function(ap)
        ap:spawnRandomCollectibleFromPool(ItemPoolType.POOL_TREASURE)
    end,
    [78001] = function(ap)
        ap:spawnRandomCollectibleFromPool(ItemPoolType.POOL_SHOP)
    end,
    [78002] = function(ap)
        ap:spawnRandomCollectibleFromPool(ItemPoolType.POOL_BOSS)
    end,
    [78003] = function(ap)
        ap:spawnRandomCollectibleFromPool(ItemPoolType.POOL_DEVIL)
    end,
    [78004] = function(ap)
        ap:spawnRandomCollectibleFromPool(ItemPoolType.POOL_ANGEL)
    end,
    [78005] = function(ap)
        ap:spawnRandomCollectibleFromPool(ItemPoolType.POOL_SECRET)
    end,
    [78006] = function(ap)
        ap:spawnRandomCollectibleFromPool(ItemPoolType.POOL_LIBRARY)
    end,
    [78007] = function(ap)
        ap:spawnRandomCollectibleFromPool(ItemPoolType.POOL_CURSE)
    end,
    [78008] = function(ap)
        ap:spawnRandomCollectibleFromPool(ItemPoolType.POOL_PLANETARIUM)
    end,
    [78009] = function(ap)
        ap:spawnRandomCollectibleFromPool(ItemPoolType.POOL_SHELL_GAME)
    end,
    [78010] = function(ap)
        ap:spawnRandomCollectibleFromPool(ItemPoolType.POOL_GOLDEN_CHEST)
    end,
    [78011] = function(ap)
        ap:spawnRandomCollectibleFromPool(ItemPoolType.POOL_RED_CHEST)
    end,
    [78012] = function(ap)
        ap:spawnRandomCollectibleFromPool(ItemPoolType.POOL_BEGGAR)
    end,
    [78013] = function(ap)
        ap:spawnRandomCollectibleFromPool(ItemPoolType.POOL_DEMON_BEGGAR)
    end,
    [78014] = function(ap)
        ap:spawnRandomCollectibleFromPool(ItemPoolType.POOL_KEY_MASTER)
    end,
    [78015] = function(ap)
        ap:spawnRandomCollectibleFromPool(ItemPoolType.POOL_BATTERY_BUM)
    end,
    [78016] = function(ap)
        ap:spawnRandomCollectibleFromPool(ItemPoolType.POOL_MOMS_CHEST)
    end,
    [78017] = function(ap)
        ap:spawnRandomCollectibleFromPool(ItemPoolType.POOL_GREED_TREASURE)
    end,
    [78018] = function(ap)
        ap:spawnRandomCollectibleFromPool(ItemPoolType.POOL_GREED_BOSS)
    end,
    [78019] = function(ap)
        ap:spawnRandomCollectibleFromPool(ItemPoolType.POOL_GREED_SHOP)
    end,
    [78020] = function(ap)
        ap:spawnRandomCollectibleFromPool(ItemPoolType.POOL_GREED_DEVIL)
    end,
    [78021] = function(ap)
        ap:spawnRandomCollectibleFromPool(ItemPoolType.POOL_GREED_ANGEL)
    end,
    [78022] = function(ap)
        ap:spawnRandomCollectibleFromPool(ItemPoolType.POOL_GREED_CURSE)
    end,
    [78023] = function(ap)
        ap:spawnRandomCollectibleFromPool(ItemPoolType.POOL_GREED_SECRET)
    end,
    [78024] = function(ap)
        ap:spawnRandomCollectibleFromPool(ItemPoolType.POOL_CRANE_GAME)
    end,
    [78025] = function(ap)
        ap:spawnRandomCollectibleFromPool(ItemPoolType.POOL_ULTRA_SECRET)
    end,
    [78026] = function(ap)
        ap:spawnRandomCollectibleFromPool(ItemPoolType.POOL_BOMB_BUM)
    end,
    [78027] = function(ap)
        ap:spawnRandomCollectibleFromPool(ItemPoolType.POOL_OLD_CHEST)
    end,
    [78028] = function(ap)
        ap:spawnRandomCollectibleFromPool(ItemPoolType.POOL_BABY_SHOP)
    end,
    [78029] = function(ap)
        ap:spawnRandomCollectibleFromPool(ItemPoolType.POOL_WOODEN_CHEST)
    end,
    [78030] = function(ap)
        ap:spawnRandomCollectibleFromPool(ItemPoolType.POOL_ROTTEN_BEGGAR)
    end,
    [78031] = function(ap)
        ap:spawnRandomPickup()
    end,
    [78032] = function(ap)
        ap:spawnRandomPickupByType(PickupVariant.PICKUP_HEART)
    end,
    [78033] = function(ap)
        ap:spawnRandomPickupByType(PickupVariant.PICKUP_COIN)
    end,
    [78034] = function(ap)
        ap:spawnRandomPickupByType(PickupVariant.PICKUP_BOMB)
    end,
    [78035] = function(ap)
        ap:spawnRandomPickupByType(PickupVariant.PICKUP_KEY)
    end,
    [78036] = function(ap)
        ap:spawnRandomPickupByType(PickupVariant.PICKUP_TAROTCARD)
    end,
    [78037] = function(ap)
        ap:spawnRandomPickupByType(PickupVariant.PICKUP_PILL)
    end,
    [78038] = function(ap)
        ap:spawnRandomChest()
    end,
    [78039] = function(ap)
        ap:spawnRandomPickupByType(PickupVariant.PICKUP_TRINKET)
    end,
    -- 78040 - 78771 are generated by AP:generateCollectableItemImpls
    [78772] = function(ap)
        ap:addToTrapQueue(78772)
    end,
    [78773] = function(ap)
        ap:addToTrapQueue(78773, 120)
    end,
    [78774] = function(ap)
        ap:addToTrapQueue(78774)
    end,
    [78775] = function(ap)
        ap:addToTrapQueue(78775)
    end,
    [78776] = function(ap)
        ap:addToTrapQueue(78776, 120)
    end,
    [78777] = function(ap)
        ap:addToTrapQueue(78777)
    end
}
AP.TRAP_IMPLS = {
    [78772] = function(ap)
        for i = 0, 5 do
            ap:addToSpawnQueue(EntityType.ENTITY_PICKUP, PickupVariant.PICKUP_BOMB, BombSubType.BOMB_TROLL, 5)
        end
    end,
    [78773] = function(ap)
        local level = Game():GetLevel()
        if (level:GetCurrentRoomDesc().Flags & RoomDescriptor.FLAG_CURSED_MIST) ~= RoomDescriptor.FLAG_CURSED_MIST then
            Game():StartRoomTransition(level:GetRandomRoomIndex(ap.SLOT_DATA.teleportTrapCanError, ap.RNG:Next()), -1,
                RoomTransitionAnim.TELEPORT)
        end
    end,
    [78774] = function(ap)
        Game():AddPixelation(300)
    end,
    [78775] = function(ap)
        local level = Game():GetLevel()
        local currentCurses = level:GetCurses()
        local curses = {LevelCurse.CURSE_OF_DARKNESS, LevelCurse.CURSE_OF_THE_LOST, LevelCurse.CURSE_OF_THE_UNKNOWN,
                        LevelCurse.CURSE_OF_MAZE, LevelCurse.CURSE_OF_BLIND}
        while #curses > 0 do
            local idx = ap.RNG:RandomInt(#curses - 1) + 1
            local curse = curses[idx]
            if currentCurses & curse == curse then
                table.remove(curses, idx)
            else
                level:AddCurse(curse, false)
                return
            end
        end
        ap:addToTrapQueue(78775)
    end,
    [78776] = function(ap)
        local player = Game():GetNearestPlayer(Isaac.GetRandomPosition())
        if player:HasCollectible(ap.AP_ITEM_TRAP_PARALISYS) then
            ap:addToTrapQueue(78776, 120)
        else
            player:AddCollectible(ap.AP_ITEM_TRAP_PARALISYS)
        end
    end,
    [78777] = function(ap)
        local player = Game():GetNearestPlayer(Isaac.GetRandomPosition())
        player:UseActiveItem(CollectibleType.COLLECTIBLE_WAVY_CAP)
    end
}

function AP:init()
    AP.INSTANCE = self
    dbg_log("called AP:init 1")
    self:generateCollectableItemImpls(78040)
    self.RNG = RNG()
    self.RNG:SetSeed(Random(), 35)
    self.DEBUG_MODE = false
    self.INFO_TEXT_SCALE = 0.5
    self.HUD_OFFSET = 5
    -- AP Connection info (initial values)
    self.HOST_ADDRESS = "localhost"
    self.HOST_PORT = "38281"
    self.PASSWORD = ""
    self.SLOT_NAME = "Player1"
    -- print("called AP:init", 1.5, self.HOST_ADDRESS, self.HOST_PORT, self.SLOT_NAME, self.PASSWORD)    
    -- ap client / statemachine
    self:initAPClient()

    self.RECONNECT_INTERVAL = 5
    self.MAX_RECONNECT_TRIES = 1
    self.RECONNECT_TRIES = 0
    self.SHOULD_AUTO_CONNECT = false
    dbg_log("called AP:init 2")
    -- Isaac mod ref
    self.MOD_REF = RegisterMod(self.MOD_NAME, 1)
    self.AP_ITEM_ID = Isaac.GetItemIdByName("AP Item")
    self.AP_ITEM_ID_CHEAP = Isaac.GetItemIdByName("AP Item (10 coins)")
    self.AP_ITEM_TRAP_PARALISYS = Isaac.GetItemIdByName("AP Trap (Paralysis)")
    self.AP_MCM = AP_MCM(self)
    self:loadConnectionInfo()
    self:loadSettings()
    -- mod callbacks
    function self.onPostGameStarted(mod, isContinued)
        dbg_log('self.onPostGameStarted')
        if not isContinued then
            self.JUST_STARTED = true
            self.JUST_STARTED_TIMER = 100
        end
        self.IS_CONTINUED = isContinued
        self.RECONNECT_TRIES = 0
        self.TRAP_QUEUE = {}
        self.TRAP_QUEUE_TIMER = 150
        self.RECEIVED_QUEUE = {}
        if self.SHOULD_AUTO_CONNECT then
            self:connectAP()
        end
    end
    function self.onPostRender(mod)
        -- dbg_log("onPostRender")`
        if self.AP_CLIENT then
            self.AP_CLIENT:poll()
        end
        self:showPermanentMessage()
        self:showMessages()
        if self.DEBUG_MODE then
            self:showDebugInfo()
        end
        self:proceedPickupTimer()
        self:advanceItemQueue()
        self:advanceTrapQueue()
        self:advanceSpawnQueue()
    end
    function self.onPreGameExit(mod, shouldSave)
        if self.AP_CLIENT and self.AP_CLIENT:get_state() == 4 then
            self:setPersistentInfoFurthestFloor()
        end
        self.ITEM_QUEUE = {}
        self.TRAP_QUEUE = {}
        self.SPAWN_QUEUE = {}
        if shouldSave then
            local seed = ""
            if self.CONNECTION_INFO and self.SLOT_DATA then
                seed = self.SLOT_DATA.seed
            end
            self:saveOtherData(seed)
        end
        self.AP_CLIENT = nil
    end
    function self.onPrePickupCollision(mod, pickup, collider, low)
        local totalLocations = self.SLOT_DATA.totalLocations
        local checkedLocations = #self.AP_CLIENT.checked_locations
        local collectableIndex = getCollectableIndex(pickup)
        if pickup.Variant ~= PickupVariant.PICKUP_COLLECTIBLE or collider.Type ~= EntityType.ENTITY_PLAYER or
            checkedLocations >= totalLocations or (pickup.Touched and pickup.SubType ~= self.AP_ITEM_ID) -- used to not make AP spawned item collectable until rerolled
        or pickup.SubType == CollectibleType.COLLECTIBLE_NULL -- might get called when bumping in a already collected collectable
        then
            return
        end
        local itemConfig = Isaac.GetItemConfig():GetCollectible(pickup.SubType)
        -- check for special items like polaroid/negative, key/knife pieces or dad's note
        if itemConfig:HasTags(ItemConfig.TAG_QUEST) then
            return
        end
        -- check timer
        if self.PICKUP_TIMER and self.PICKUP_TIMER > 0 then
            return false
        end
        local player = collider:ToPlayer()
        local room = Game():GetRoom()
        -- check if we can buy this, if shop item
        if pickup:IsShopItem() then
            if pickup.Price > 0 then
                if pickup.Price > collider:ToPlayer():GetNumCoins() then
                    return
                end
                -- 1 or 2 hearts deal
            elseif pickup.Price > -3 then
                if pickup.Price * -2 > player:GetMaxHearts() and not player:WillPlayerRevive() then
                    return
                end
                -- 3 soul hearts deal
            elseif pickup.Price == -3 then
                if pickup.Price * -2 > player:GetSoulHearts() and not player:WillPlayerRevive() then
                    return
                end
                -- 1 heart/2 soul hearts deal
            elseif pickup.Price == -4 then
                if (player:GetMaxHearts() < 2 or player:GetSoulHearts() < 4) and not player:WillPlayerRevive() then
                    return
                end
            end
        end
        -- mod:RemoveCallback(ModCallbacks.MC_PRE_PICKUP_COLLISION, self.onPrePickupCollision)
        self.PICKUP_TIMER = 90
        if player:CanPickupItem() and pickup.Wait <= 0 and pickup.SubType ~= self.AP_ITEM_ID then
            -- print("onPrePickupCollision", pickup.Wait, pickup.State)
            local item_step = self.SLOT_DATA.itemPickupStep
            self.CUR_ITEM_STEP_VAL = self.CUR_ITEM_STEP_VAL + 1
            print('item is potential AP item', item_step, self.CUR_ITEM_STEP_VAL, #self.AP_CLIENT.missing_locations,
                pickup.SubType, pickup.State)
            if self.CUR_ITEM_STEP_VAL == item_step then
                -- self:clearLocations(1)                
                self.CUR_ITEM_STEP_VAL = 0
                local itemConfig = Isaac.GetItemConfig():GetCollectible(pickup.SubType)
                print("onPrePickupCollision", self.AP_ITEM_ID)
                if (itemConfig.ShopPrice == 10) then
                    pickup:Morph(EntityType.ENTITY_PICKUP, PickupVariant.PICKUP_COLLECTIBLE, self.AP_ITEM_ID_CHEAP,
                        true, true, true)
                else
                    pickup:Morph(EntityType.ENTITY_PICKUP, PickupVariant.PICKUP_COLLECTIBLE, self.AP_ITEM_ID, true,
                        true, true)
                end
                pickup.Touched = true -- ToDo: Test with boss rush/challenge rooms
                if itemConfig and itemConfig.Quality > 1 then
                    player:AnimateSad()
                else
                    player:AnimateHappy()
                end
                -- mod:AddCallback(ModCallbacks.MC_PRE_PICKUP_COLLISION, self.onPrePickupCollision)
                return false
            end
        end
        -- mod:AddCallback(ModCallbacks.MC_PRE_PICKUP_COLLISION, self.onPrePickupCollision)
    end
    function self.onPostPEffectUpdate(mod, player)
        if player:HasCollectible(self.AP_ITEM_ID) then
            self:clearLocations(1)
            player:RemoveCollectible(self.AP_ITEM_ID)
        end
        if player:HasCollectible(self.AP_ITEM_ID_CHEAP) then
            self:clearLocations(1)
            player:RemoveCollectible(self.AP_ITEM_ID_CHEAP)
        end
        if player:HasCollectible(self.AP_ITEM_TRAP_PARALISYS) then
            player:UsePill(PillEffect.PILLEFFECT_PARALYSIS, PillColor.PILL_NULL)
            player:RemoveCollectible(self.AP_ITEM_TRAP_PARALISYS)
        end
    end
    function self.onPreSpawnClearAward(mod)
        local room = Game():GetRoom()
        local goal = tonumber(self.SLOT_DATA.goal)
        -- print("self.onPreSpawnClearAward", room, goal)
        -- check for boss rush
        if room:GetType() == RoomType.ROOM_BOSSRUSH and room:IsAmbushDone() and room:IsClear() then
            if self.SLOT_DATA.additionalBossRewards then
                self:clearLocations(2)
            end
            if goal == 9 then
                self:sendGoalReached()
            elseif goal == 16 or goal == 17 then
                self:setPersistentNoteInfo(self.NOTE_TYPES.STAR, Isaac.GetPlayer():GetPlayerType(), self:isHardMode())
            end
        end
    end
    function self.onPostEntityKill(mod, entity)
        local player = entity:ToPlayer()
        -- ToDo: make send DeathLink on revive a option?
        if player and self.SLOT_DATA.deathLink and self.SLOT_DATA.deathLink == 1 and not player:WillPlayerRevive() then
            self:sendDeathLinkBounce()
            self:addMessage({
                parts = {{
                    msg = "[DeathLink] Sent DeathLink",
                    color = COLORS.RED
                }}
            })
        end
        local goal = tonumber(self.SLOT_DATA.goal)
        local required_locations = tonumber(self.SLOT_DATA.requiredLocations)
        local type = entity.Type
        -- print('called entityKill', 1, entity, type, entity.Variant, goal, required_locations, #self.CHECKED_LOCATIONS)
        local isGoalBoss = false
        for _, v in pairs(self.GOAL_BOSSES) do
            if contains(v, type) then
                isGoalBoss = true
                break
            end
        end
        if not isGoalBoss then
            return
        end
        local level = Game():GetLevel()
        -- don't send out rewards/goal for other goal bosses in The Void
        if type ~= EntityType.ENTITY_DELIRIUM and level:GetStage() == LevelStage.STAGE7 then
            return
        end
        -- lamb special handling
        if type == EntityType.ENTITY_THE_LAMB then
            if entity.Variant == 10 then
                self.LAMB_BODY_KILL = true
            else
                self.LAMB_KILL = true
            end
            dbg_log("Lamb Kill info changed: LAMB_BODY_KILL: "..tostring(self.LAMB_BODY_KILL).." LAMB_KILL: "..tostring(self.LAMB_KILL))
        end
        if isGoalBoss and self.SLOT_DATA.additionalBossRewards then
            self:sendBossClearReward(entity)
        end
        -- we can only win if we check enough locations
        if #self.AP_CLIENT.checked_locations < required_locations and goal ~= 16 and goal ~= 17 then
            return
        end
        local bosses = self.GOAL_BOSSES[goal]
        -- print('called entityKill', 2, dump_table(bosses), type)
        if not contains(bosses, type) then
            return
        end
        print('called entityKill', 3, "is goal boss", type, entity.Variant)  
        local playerType = Isaac.GetPlayer():GetPlayerType()
        local isHardMode = self:isHardMode()
        -- blue baby uses a SubType of Isaac => requries special handling
        if type == EntityType.ENTITY_ISAAC then
            if (goal == 2 or goal == 3) and entity.Variant == 0 then
                self:sendGoalReached()
            elseif (goal == 5 or goal == 6) and entity.Variant == 1 then
                self:sendGoalReached()
            elseif goal == 16 or goal == 17 then
                if entity.Variant == 0 then
                    self:setPersistentNoteInfo(self.NOTE_TYPES.CROSS, playerType, isHardMode)
                elseif entity.Variant == 1 then
                    self:setPersistentNoteInfo(self.NOTE_TYPES.POLAROID, playerType, isHardMode)
                end
            end
            return
            -- phase 2 is Variant 10 and ending phase 1 counts as killing Variant 0 sometimes => requries special handling
        elseif type == EntityType.ENTITY_SATAN then
            if entity.Variant == 10 then
                if (goal == 2 or goal == 4) then
                    self:sendGoalReached()
                elseif goal == 16 or goal == 17 then
                    self:setPersistentNoteInfo(self.NOTE_TYPES.INVERTED_CROSS, playerType, isHardMode)
                end
            end
            return
            -- the lamb uses two entities The Lamb itself + the body => requries special handling
        elseif type == EntityType.ENTITY_THE_LAMB then
            if self.LAMB_KILL and self.LAMB_BODY_KILL then
                dbg_log("lamb dead?")
                if goal == 5 or goal == 7 then
                    self:sendGoalReached()
                elseif goal == 16 or goal == 17 then
                    self:setPersistentNoteInfo(self.NOTE_TYPES.NEGATIVE, playerType, isHardMode)
                end
            end
            return
            -- Dogma uses Variant == 2 for the 2nd phase
        elseif type == EntityType.ENTITY_DOGMA then
            if goal == 11 and entity.Variant == 2 then
                self:sendGoalReached()
            end
            return
            -- Variant 0 is the final kill
        elseif type == EntityType.ENTITY_BEAST then
            if entity.Variant == 0 then
                if goal == 12 then
                    self:sendGoalReached()
                elseif goal == 16 or goal == 17 then
                    self:setPersistentNoteInfo(self.NOTE_TYPES.DADS_NOTE, playerType, isHardMode)
                end
            end
            return
            -- Mother uses Variant == 10 for the 2nd phase
        elseif type == EntityType.ENTITY_MOTHER then
            if entity.Variant == 10 then
                if goal == 13 then
                    self:sendGoalReached()
                elseif goal == 16 or goal == 17 then
                    self:setPersistentNoteInfo(self.NOTE_TYPES.KNIFE, playerType, isHardMode)
                end
            end
            return
        else
            if goal ~= 16 and goal ~= 17 then
                self:sendGoalReached()
            else
                if type == EntityType.ENTITY_MOMS_HEART then
                    self:setPersistentNoteInfo(self.NOTE_TYPES.HEART, playerType, isHardMode)
                elseif type == EntityType.ENTITY_MEGA_SATAN_2 then
                    self:setPersistentNoteInfo(self.NOTE_TYPES.BRIMSTONE, playerType, isHardMode)
                elseif type == EntityType.ENTITY_HUSH then
                    self:setPersistentNoteInfo(self.NOTE_TYPES.HUSHS_FACE, playerType, isHardMode)
                elseif type == EntityType.ENTITY_ULTRA_GREED then
                    self:setPersistentNoteInfo(self.NOTE_TYPES.CENT_SIGN, playerType, isHardMode)
                elseif type == EntityType.ENTITY_DELIRIUM then
                    self:setPersistentNoteInfo(self.NOTE_TYPES.WRINKLED_PAPER, playerType, isHardMode)
                end
            end
            return
        end
    end
    function self.onPostNewLevel()
        local stage = self:getStageNum()
        if self.FURTHEST_FLOOR < stage then
            self.FURTHEST_FLOOR = stage
            self:setPersistentInfoFurthestFloor()
        end
        if self.LAST_FLOOR ~= stage then
            self.LAST_FLOOR = stage
            self.ITEM_QUEUE_CURRENT_MAX = stage * self.ITEM_QUEUE_MAX_PER_FLOOR
        end
    end
    self.MOD_REF:AddCallback(ModCallbacks.MC_POST_GAME_STARTED, self.onPostGameStarted)
    self.MOD_REF:AddCallback(ModCallbacks.MC_POST_RENDER, self.onPostRender)
    self.MOD_REF:AddCallback(ModCallbacks.MC_PRE_GAME_EXIT, self.onPreGameExit)
    self.MOD_REF:AddCallback(ModCallbacks.MC_PRE_PICKUP_COLLISION, self.onPrePickupCollision)
    self.MOD_REF:AddCallback(ModCallbacks.MC_POST_PEFFECT_UPDATE, self.onPostPEffectUpdate)
    self.MOD_REF:AddCallback(ModCallbacks.MC_POST_ENTITY_KILL, self.onPostEntityKill)
    self.MOD_REF:AddCallback(ModCallbacks.MC_PRE_SPAWN_CLEAN_AWARD, self.onPreSpawnClearAward)
    self.MOD_REF:AddCallback(ModCallbacks.MC_POST_NEW_LEVEL, self.onPostNewLevel)
    print("called AP:init", 3)
    -- global Isaac info
    self.IS_CONTINUED = false
    self.HAS_SEND_GOAL_MSG = false
    -- -- goal related
    self.GOAL_BOSSES = {
        [0] = {EntityType.ENTITY_MOM}, -- TESTED (alt mom still to be tested)
        [1] = {EntityType.ENTITY_MOMS_HEART}, -- TESTED
        [2] = {EntityType.ENTITY_ISAAC, EntityType.ENTITY_SATAN}, -- TESTED
        [3] = {EntityType.ENTITY_ISAAC}, -- TESTED
        [4] = {EntityType.ENTITY_SATAN}, -- TESTED
        [5] = {EntityType.ENTITY_ISAAC, EntityType.ENTITY_THE_LAMB}, -- blue baby uses a SubType of Isaac => requries special handling
        [6] = {EntityType.ENTITY_ISAAC}, -- blue baby uses a SubType of Isaac => requries special handling; TESTED
        [7] = {EntityType.ENTITY_THE_LAMB}, -- the lamb uses two entities The Lamb itself + the body => requries special handling -- TESTED
        [8] = {EntityType.ENTITY_MEGA_SATAN_2},
        -- [9] = {}, --boss rush requries special handling -- TESTED
        [10] = {EntityType.ENTITY_HUSH}, -- TESTED
        [11] = {EntityType.ENTITY_DOGMA}, -- TESTED
        [12] = {EntityType.ENTITY_BEAST}, -- TESTED
        [13] = {EntityType.ENTITY_MOTHER}, -- TESTED
        [14] = {EntityType.ENTITY_DELIRIUM}, -- TESTED
        [15] = {},
        [16] = {EntityType.ENTITY_MOMS_HEART, EntityType.ENTITY_ISAAC, EntityType.ENTITY_SATAN,
                EntityType.ENTITY_THE_LAMB, EntityType.ENTITY_MEGA_SATAN_2, EntityType.ENTITY_HUSH,
                EntityType.ENTITY_DOGMA, EntityType.ENTITY_BEAST, EntityType.ENTITY_MOTHER, EntityType.ENTITY_DELIRIUM},
        [17] = {EntityType.ENTITY_MOMS_HEART, EntityType.ENTITY_ISAAC, EntityType.ENTITY_SATAN,
                EntityType.ENTITY_THE_LAMB, EntityType.ENTITY_MEGA_SATAN_2, EntityType.ENTITY_HUSH,
                EntityType.ENTITY_DOGMA, EntityType.ENTITY_BEAST, EntityType.ENTITY_MOTHER, EntityType.ENTITY_DELIRIUM}
    }
    self.GOAL_NAMES = {
        [0] = "Mom",
        [1] = "Mom's Heart",
        [2] = "Isaac/Satan",
        [3] = "Isaac",
        [4] = "Satan",
        [5] = "???/The Lamb",
        [6] = "???",
        [7] = "The Lamb",
        [8] = "Mega Satan",
        [9] = "Boss Rush",
        [10] = "Hush",
        [11] = "Dogma",
        [12] = "The Beast",
        [13] = "Mother",
        [14] = "Delirium",
        [15] = "Required locations",
        [16] = "Full Note(s)",
        [17] = "Note Marks"
    }
    self.NOTE_TYPES = {
        HEART = 0,
        CROSS = 1,
        POLAROID = 2,
        INVERTED_CROSS = 3,
        NEGATIVE = 4,
        BRIMSTONE = 5,
        STAR = 6,
        HUSHS_FACE = 7,
        -- CENT_SIGN = 8,
        WRINKLED_PAPER = 9,
        KNIFE = 10,
        DADS_NOTE = 11
    }
    self.NOTE_CHARS = {
        [0] = {PlayerType.PLAYER_ISAAC},
        [1] = {PlayerType.PLAYER_MAGDALENE},
        [2] = {PlayerType.PLAYER_CAIN},
        [3] = {PlayerType.PLAYER_JUDAS, PlayerType.PLAYER_BLACKJUDAS},
        [4] = {PlayerType.PLAYER_BLUEBABY},
        [5] = {PlayerType.PLAYER_EVE},
        [6] = {PlayerType.PLAYER_SAMSON},
        [7] = {PlayerType.PLAYER_AZAZEL},
        [8] = {PlayerType.PLAYER_LAZARUS, PlayerType.PLAYER_LAZARUS2},
        [9] = {PlayerType.PLAYER_EDEN},
        [10] = {PlayerType.PLAYER_THELOST},
        [11] = {PlayerType.PLAYER_LILITH},
        [12] = {PlayerType.PLAYER_KEEPER},
        [13] = {PlayerType.PLAYER_APOLLYON},
        [14] = {PlayerType.PLAYER_THESOUL},
        [15] = {PlayerType.PLAYER_BETHANY},
        [16] = {PlayerType.PLAYER_JACOB},
        [17] = {PlayerType.PLAYER_ESAU},
        [18] = {PlayerType.PLAYER_ISAAC_B},
        [19] = {PlayerType.PLAYER_MAGDALENE_B},
        [20] = {PlayerType.PLAYER_CAIN_B},
        [21] = {PlayerType.PLAYER_JUDAS_B},
        [22] = {PlayerType.PLAYER_BLUEBABY_B},
        [23] = {PlayerType.PLAYER_EVE_B},
        [24] = {PlayerType.PLAYER_SAMSON_B},
        [25] = {PlayerType.PLAYER_AZAZEL_B},
        [26] = {PlayerType.PLAYER_LAZARUS_B, PlayerType.PLAYER_LAZARUS2_B},
        [27] = {PlayerType.PLAYER_EDEN_B},
        [28] = {PlayerType.PLAYER_THELOST_B},
        [29] = {PlayerType.PLAYER_LILITH_B},
        [30] = {PlayerType.PLAYER_KEEPER_B},
        [31] = {PlayerType.PLAYER_APOLLYON_B},
        [32] = {PlayerType.PLAYER_THEFORGOTTEN_B},
        [33] = {PlayerType.PLAYER_BETHANY_B},
        [34] = {PlayerType.PLAYER_JACOB_B, PlayerType.PLAYER_JACOB2_B}
    }
    self.LAMB_KILL = false
    self.LAMB_BODY_KILL = false
    -- -- restock fix related
    self.PICKUP_TIMER = 0
    -- global AP info
    self.LAST_RECEIVED_ITEM_INDEX = -1
    self.CUR_ITEM_STEP_VAL = 0
    self.CONNECTION_INFO = nil
    self.ROOM_INFO = nil
    self.MESSAGE_QUEUE = {}
    self.ITEM_QUEUE = {}
    self.ITEM_QUEUE_COUNTER = 0
    self.ITEM_QUEUE_CURRENT_MAX = 0
    self.ITEM_QUEUE_MAX_PER_FLOOR = 0
    self.FURTHEST_FLOOR = 1
    self.LAST_FLOOR = 1
    self.JUST_STARTED = false
    self.JUST_STARTED_TIMER = 0
    self.TRAP_QUEUE = {}
    self.TRAP_QUEUE_TIMER = 0
    self.SPAWN_QUEUE = {}
    self.SPAWN_QUEUE_TIMER = 0
    self.DEATH_CAUSE = "unknown"
    self.LAST_DEATH_LINK_TIME = nil
    self.LAST_DEATH_LINK_RECV = nil -- ToDo: Implement?
    self.NOTE_INFO = {}
    self.COMPLETED_NOTES = 0
    self.COMPLETED_NOTE_MARKS = 0
    print("called AP:init", 4, "end")
end

-- AP Commands
function AP:getConnectCommand()
    return {
        cmd = "Connect",
        game = self.GAME_NAME,
        name = self.SLOT_NAME,
        password = self.PASSWORD,
        uuid = "1",
        version = {
            major = self.MAJOR_VERSION,
            minor = self.MINOR_VERSION,
            build = self.BUILD_VERSION,
            class = "Version"
        },
        items_handling = 7, -- gimme all the items
        tags = {}
    }
end
function AP:getDataPackageCommand()
    return {
        cmd = "GetDataPackage",
        games = self.OUTDATED_GAMES
    }
end
function AP:getLocationCollectedCommand(ids)
    return {
        cmd = "LocationChecks",
        locations = ids
    }
end
function AP:getLocationScoutCommand(ids, create_as_hint)
    if not create_as_hint then
        create_as_hint = 0
    end
    return {
        cmd = "LocationScouts",
        locations = ids,
        create_as_hint = create_as_hint
    }
end
function AP:getUpdateConnectionTagsCommand(tags)
    tags = tags or {}
    return {
        cmd = "ConnectUpdate",
        tags = tags
    }
end
function AP:getSetCommand(key, operations, want_reply, default)
    if not default then
        default = "null"
    end
    return {
        cmd = "Set",
        key = key,
        default = default,
        want_reply = want_reply,
        operations = operations
    }
end

function AP:getSetNotifyCommand(keys)
    return {
        cmd = "SetNotify",
        keys = keys
    }
end
function AP:getGetCommand(keys)
    -- print("AP:getGetCommand", dump_table(keys))
    return {
        cmd = "Get",
        keys = keys
    }
end
-- AP END Commands

-- AP util funcs

function AP:getTypeFromDataStorageKey(k)
    -- print("AP:getTypeFromDataStorageKey")
    local type = "invalid"
    local splitResult = split(k, "_")
    if #splitResult >= 4 then
        if splitResult[1] == "tobir" and tonumber(splitResult[2]) == self.CONNECTION_INFO.team and
            tonumber(splitResult[3]) == self.CONNECTION_INFO.slot then
            type = splitResult[4]
        end
    end
    return type
end
function AP:setupLocalNoteInfo()
    -- print("AP:setupLocalNoteInfo")
    self.NOTE_INFO = {}
    for k, v in pairs(self.NOTE_CHARS) do
        self.NOTE_INFO[k] = {}
        for k2, v2 in pairs(self.NOTE_TYPES) do
            self.NOTE_INFO[k][v2] = false
        end
    end
    -- print("AP:setupLocalNoteInfo",2, dump_table(self.NOTE_INFO))
end
function AP:countNoteMarksForPlayerType(player_type)
    local char = -1
    for k, v in pairs(self.NOTE_CHARS) do
        if contains(v, player_type) then
            char = k
            break
        end
    end
    if char == -1 then
        return
    end
    -- print("AP:countNoteMarksForPlayerType", char, dump_table(self.NOTE_INFO))
    if not self.NOTE_INFO[char] then
        return 0
    end
    local count = 0
    for _, v in pairs(self.NOTE_TYPES) do
        if self.NOTE_INFO[char][v] then
            count = count + 1
        end
    end
    return count
end
function AP:checkNoteInfo()
    -- print("AP:checkNoteInfo", 1, dump_table(self.NOTE_INFO))
    local required_locations = tonumber(self.SLOT_DATA.requiredLocations)
    local reqNoteAmount = tonumber(self.SLOT_DATA.fullNoteAmount)
    local reqNoteMarksAmount = tonumber(self.SLOT_DATA.noteMarksAmount)
    local goal = tonumber(self.SLOT_DATA.goal)
    if goal ~= 16 and goal ~= 17 then
        return
    end
    local count = 0
    local countMarks = 0
    for k, v in pairs(self.NOTE_CHARS) do
        if self.NOTE_INFO[k] then
            local complete = true
            for k2, v2 in pairs(self.NOTE_TYPES) do
                if not self.NOTE_INFO[k][v2] and goal == 16 then
                    complete = false
                    break
                elseif self.NOTE_INFO[k][v2] and goal == 17 then
                    countMarks = countMarks + 1
                end
            end
            if complete then
                count = count + 1
                if count >= reqNoteAmount and goal == 16 then
                    break
                end
            end
        end
    end
    self.COMPLETED_NOTES = count
    self.COMPLETED_NOTE_MARKS = countMarks
    if ((count >= reqNoteAmount and goal == 16) or (countMarks >= reqNoteMarksAmount and goal == 17)) then
        if #self.AP_CLIENT.checked_locations >= required_locations then
            self:sendGoalReached()
        else
            self:addMessage({
                parts = {{
                    msg = "You have enough note marks to beat the game but are still missing required locations.",
                    color = COLORS.GREEN
                }}
            })
        end

    end
end
function AP:setupPersistentNoteInfo()
    print("AP:setupPersistentNoteInfo")
    local keys = {}
    for k, v in pairs(self.NOTE_TYPES) do
        for k2, v2 in pairs(self.NOTE_CHARS) do
            table.insert(keys, self:getNoteInfoKey(v, k2))
        end
    end
    self.AP_CLIENT:Get(keys)
    self.AP_CLIENT:SetNotify(keys)
end
function AP:syncNoteInfoFromDict(dict)
    -- print("AP:syncNoteInfoFromDict", dump_table(dict), dump_table(self.NOTE_INFO))
    local goal = tonumber(self.SLOT_DATA.goal)
    if goal ~= 16 and goal ~= 17 then
        return
    end
    for k, v in pairs(dict) do
        if self:getTypeFromDataStorageKey(k) == "note" then
            local splitResult = split(k, "_")
            if #splitResult >= 6 then
                local note_type = tonumber(splitResult[5])
                local note_char = tonumber(splitResult[6])
                self.NOTE_INFO[note_char][note_type] = (v == 1)
            end
        end
    end
    self:checkNoteInfo()
end
function AP:isHardMode()
    -- print("AP:isHardMode")
    local diff = Game().Difficulty
    return diff == 1 or diff == 3
end
function AP:getNoteInfoKey(note_type, char)
    -- print("AP:getNoteInfoKey", note_type, char)
    local team = tonumber(self.CONNECTION_INFO.team)
    local slot = tonumber(self.CONNECTION_INFO.slot)
    return "tobir_" .. team .. "_" .. slot .. "_note_" .. note_type .. "_" .. char
end
function AP:setPersistentNoteInfo(note_type, player_type, isHardMode)
    print("AP:setPersistentNoteInfo", note_type, player_type, isHardMode)
    local goal = tonumber(self.SLOT_DATA.goal)
    if goal ~= 16 and goal ~= 17 then
        return
    end
    local noteMarkRequireHardMode = self.SLOT_DATA.noteMarkRequireHardMode
    -- print("AP:setPersistentNoteInfo", 2, noteMarkRequireHardMode)
    if noteMarkRequireHardMode and not isHardMode then
        return
    end
    local char = -1
    for k, v in pairs(self.NOTE_CHARS) do
        -- print("AP:setPersistentNoteInfo", 3, player_type, dump_table(v))
        if contains(v, player_type) then
            char = k
            break
        end
    end
    if char == -1 then
        return
    end
    local key = self:getNoteInfoKey(note_type, char)
    self.AP_CLIENT:Set(key, 0, true, {{"replace", 1}})
end
function AP:getStageNum()
    local stage = Game():GetLevel():GetStage()
    -- we hard limit stage num at 12 so home and the void will always receive all items
    if stage == LevelStage.STAGE8 then
        stage = 12
    end
    return stage
end
function AP:syncFurthestFloor(dict)
    local team = tonumber(self.CONNECTION_INFO.team)
    local slot = tonumber(self.CONNECTION_INFO.slot)
    local key = "tobir_" .. team .. "_" .. slot .. "_floor"
    -- print("AP:syncFurthestFloor", dump_table(dict))
    if dict[key] == nil then
        return
    end
    self.FURTHEST_FLOOR = dict[key]
    self.ITEM_QUEUE_COUNTER = 0
    self.ITEM_QUEUE_MAX_PER_FLOOR = math.ceil(#self.ITEM_QUEUE / self.FURTHEST_FLOOR)
    self.ITEM_QUEUE_CURRENT_MAX = self:getStageNum() * self.ITEM_QUEUE_MAX_PER_FLOOR
    -- print("AP:syncFurthestFloor", self.FURTHEST_FLOOR, self.ITEM_QUEUE_MAX_PER_FLOOR, #self.ITEM_QUEUE)
end
function AP:getPersistentInfoFurthestFloor()
    -- print("AP:getPersistentInfoFurthestFloor")
    local team = tonumber(self.CONNECTION_INFO.team)
    local slot = tonumber(self.CONNECTION_INFO.slot)
    local key = "tobir_" .. team .. "_" .. slot .. "_floor"
    self.AP_CLIENT:Get({key})
end
function AP:setPersistentInfoFurthestFloor(op)
    if not op then
        op = "max"
    end
    local team = tonumber(self.CONNECTION_INFO.team)
    local slot = tonumber(self.CONNECTION_INFO.slot)
    local key = "tobir_" .. team .. "_" .. slot .. "_floor"
    self.AP_CLIENT:Set(key, 1, true, {{op, self.FURTHEST_FLOOR}})
end
function AP:generateCollectableItemImpls(startIdx)
    for i = 0, CollectibleType.NUM_COLLECTIBLES - 2 do
        AP.ITEM_IMPLS[startIdx + i] = function(ap)
            ap:spawnCollectible(i + 1, true)
            -- print(i + 1)
        end
    end
end
function AP:clearLocations(amount)
    amount = amount or 1
    if amount > #self.AP_CLIENT.missing_locations then
        amount = #self.AP_CLIENT.missing_locations
    end
    local ids = {}
    table.move(self.AP_CLIENT.missing_locations, 1, amount, 1, ids)
    dbg_log("clearLocations" .. dump_table(ids) .. " " .. tostring(amount) .. " " ..
                tostring(#self.AP_CLIENT.missing_locations))
    self:sendLocationsCleared(ids)
end
function AP:sendBossClearReward(entity)
    local type = entity.Type
    local variant = entity.Variant

    -- boss rush is handled via onPreSpawnClearAward
    if type == EntityType.ENTITY_MOM and variant == 10 then
        self:clearLocations(1)
    elseif type == EntityType.ENTITY_MOMS_HEART and variant == 10 then
        self:clearLocations(2)
    elseif (type == EntityType.ENTITY_ISAAC and variant == 0) or
        (type == EntityType.ENTITY_SATAN and variant == 10 and not self.SATAN_KILL) or type == EntityType.ENTITY_HUSH then
        self:clearLocations(3)
        if type == EntityType.ENTITY_SATAN then
            self.SATAN_KILL = true -- dies twice
        end
    elseif (type == EntityType.ENTITY_ISAAC and variant == 1) or
        (type == EntityType.ENTITY_THE_LAMB and self.LAMB_KILL and self.LAMB_BODY_KILL) then
        self:clearLocations(4)
    elseif type == EntityType.ENTITY_MEGA_SATAN_2 or type == EntityType.ENTITY_DELIRIUM or
        (type == EntityType.ENTITY_MOTHER and variant == 10) or (type == EntityType.ENTITY_BEAST and variant == 0) then
        self:clearLocations(5)
    elseif type == EntityType.ENTITY_DOGMA then
        -- do nothing   
    else
        print("!!! tried to send clear reward for unknown goal boss !!!")
    end
end

function AP:collectItem(item)
    local id = item.item
    local roomDesc = Game():GetLevel():GetCurrentRoomDesc().Data
    if roomDesc.Name == "Beast Room" then -- dont receive items in the beast room
        return
    end
    if self.JUST_STARTED and self.SLOT_DATA.splitStartItems and self.SLOT_DATA.splitStartItems > 0 then
        self:addToItemQueue(id)
        return
    end
    local item_impl = AP.ITEM_IMPLS[id]
    if item_impl == nil or type(item_impl) ~= 'function' then
        print("!!! received unknown item id  !!!", id)
        return
    end
    item_impl(self)
end
function AP:addToSpawnQueue(type, variant, subType, timeToNextSpawn)
    table.insert(self.SPAWN_QUEUE, {
        type = type,
        variant = variant,
        subType = subType,
        timeToNextSpawn = timeToNextSpawn
    })
end
function AP:addToTrapQueue(trapId, dur)
    if not dur then
        dur = 30
    end
    table.insert(self.TRAP_QUEUE, {
        id = trapId,
        dur = dur
    })
end
function AP:advanceSpawnQueue()
    if self.SPAWN_QUEUE_TIMER > 0 then
        self.SPAWN_QUEUE_TIMER = self.SPAWN_QUEUE_TIMER - 1
        return
    end
    if #self.SPAWN_QUEUE < 1 then
        return
    end
    local item = self.SPAWN_QUEUE[1]
    table.remove(self.SPAWN_QUEUE, 1)
    self.SPAWN_QUEUE_TIMER = item.timeToNextSpawn
    local room = Game():GetRoom()
    local pos = room:FindFreeTilePosition(room:GetRandomPosition(1), 5)
    Isaac.Spawn(item.type, item.variant, item.subType, pos, Vector(0, 0), nil)
end
function AP:advanceJustStartedTimer()
    if not self.JUST_STARTED then
        return
    end
    if self.JUST_STARTED_TIMER <= 0 then
        self.JUST_STARTED = false
        return
    end
    self.JUST_STARTED_TIMER = self.JUST_STARTED_TIMER - 1
end
function AP:advanceItemQueue()
    if #self.ITEM_QUEUE < 1 then
        return
    end
    if self.ITEM_QUEUE_COUNTER >= self.ITEM_QUEUE_CURRENT_MAX then
        return
    end
    print("AP:advanceItemQueue", self.FURTHEST_FLOOR, self.ITEM_QUEUE_COUNTER, self.ITEM_QUEUE_MAX_PER_FLOOR,
        self.ITEM_QUEUE_CURRENT_MAX, #self.ITEM_QUEUE)
    local randIndex = self.RNG:RandomInt(#self.ITEM_QUEUE) + 1
    local id = self.ITEM_QUEUE[randIndex]
    table.remove(self.ITEM_QUEUE, randIndex)
    local item_impl = AP.ITEM_IMPLS[id]
    if item_impl == nil or type(item_impl) ~= 'function' then
        print("!!! received unknown item id  !!!", id)
        return
    end
    item_impl(self)
    self.ITEM_QUEUE_COUNTER = self.ITEM_QUEUE_COUNTER + 1
end
function AP:addToItemQueue(item, pos)
    pos = pos or #self.ITEM_QUEUE + 1
    table.insert(self.ITEM_QUEUE, pos, item)
end
function AP:advanceTrapQueue()
    if self.TRAP_QUEUE_TIMER > 0 then
        self.TRAP_QUEUE_TIMER = self.TRAP_QUEUE_TIMER - 1
        return
    end
    if #self.TRAP_QUEUE < 1 then
        return
    end
    local trap = self.TRAP_QUEUE[1]
    table.remove(self.TRAP_QUEUE, 1)
    self.TRAP_QUEUE_TIMER = trap.dur
    local trap_impl = AP.TRAP_IMPLS[trap.id]
    if trap_impl == nil or type(trap_impl) ~= 'function' then
        print("!!! received unknown trap id  !!!", id)
        return
    end
    trap_impl(self)
end
function AP:spawnCollectible(item, forceItem)
    local player = Game():GetNearestPlayer(Isaac.GetRandomPosition())
    local item_config = Isaac:GetItemConfig():GetCollectible(item)
    -- print("AP:spawnCollectible", player:GetCollectibleCount())
    if (item_config.Type ~= ItemType.ITEM_ACTIVE or player:GetActiveItem(ActiveSlot.SLOT_PRIMARY) == 0) and
        not (player:GetPlayerType() == PlayerType.PLAYER_ISAAC_B and player:GetCollectibleCount() > 8) and item ~=
        CollectibleType.COLLECTIBLE_TMTRAINER then
        -- FixMe: transformations cause graphical glitches sometimes
        -- player:QueueItem(item_config)        
        -- player:FlushQueueItem()
        player:AddCollectible(item)
    else
        local room = Game():GetRoom()
        local num = 1
        local startPos = room:GetClampedPosition(Vector(player.Position.X, player.Position.Y - 1), 0)
        local pos = room:FindFreePickupSpawnPosition(startPos, num, true, false)
        -- print("AP:spawnCollectible", "before loop", pos, num, item)
        while not checkPos(pos, player) and num < 500 do
            num = num + 1
            pos = room:FindFreePickupSpawnPosition(startPos, num, true, false)
            -- print("AP:spawnCollectible", "in loop", pos, num)
        end
        -- print("AP:spawnCollectible", "after loop", pos, num)
        local entity = Isaac.Spawn(EntityType.ENTITY_PICKUP, PickupVariant.PICKUP_COLLECTIBLE, item, pos, Vector(0, 0),
            nil)
        local pickup = entity:ToPickup()
        if forceItem then
            -- make sure the item does not change into anything else
            pickup:Morph(EntityType.ENTITY_PICKUP, PickupVariant.PICKUP_COLLECTIBLE, item, true, true, true)
        end
        -- used to not make AP spawned item collectable until rerolled
        pickup.Touched = true
    end
end
function AP:spawnRandomCollectibleFromPool(pool)
    local item = Game():GetItemPool():GetCollectible(pool, true)
    self:spawnCollectible(item)
end
function AP:spawnRandomPickup()
    self:spawnRandomPickupByType(PICKUP_TYPES[self.RNG:RandomInt(#PICKUP_TYPES) + 1])
end
function AP:spawnRandomChest()
    self:spawnRandomPickupByType(CHEST_TYPES[self.RNG:RandomInt(#CHEST_TYPES) + 1])
end
function AP:spawnRandomPickupByType(type, subtype)
    if not subtype then
        subtype = 0
    end
    local player = Game():GetNearestPlayer(Isaac.GetRandomPosition())
    local room = Game():GetRoom()
    local num = 1
    local pos = room:FindFreePickupSpawnPosition(player.Position, num, true, false)
    -- print("AP:spawnRandomPickupByType", "before loop", pos, num, subtype)
    while not checkPos(pos, player) and num < 100 do
        num = num + 1
        pos = room:FindFreePickupSpawnPosition(player.Position, num, true, false)
        -- print("AP:spawnRandomPickupByType", "in loop", pos, num, subtype)
    end
    -- print("AP:spawnRandomPickupByType", "after loop", pos, num, subtype)
    Isaac.Spawn(EntityType.ENTITY_PICKUP, type, subtype, pos, Vector(0, 0), nil)
end

-- AP message printing
function AP:addMessage(msg)
    dbg_log("AP:addMessage")
    if not msg then
        return
    end
    if type(msg) == "string" then
        msg = {
            parts = {{
                msg = msg,
                color = {
                    A = 1,
                    R = 255,
                    G = 255,
                    B = 255
                },
                width = Isaac.GetTextWidth(msg)
            }}
        }
    end
    if type(msg) ~= "table" then
        return
    end
    msg.timer = 250
    table.insert(self.MESSAGE_QUEUE, msg)
end
function AP:proceedMessageQueue()
    for i = 1, 3 do
        if self.MESSAGE_QUEUE[1] and self.MESSAGE_QUEUE[1].timer <= 0 then
            table.remove(self.MESSAGE_QUEUE, 1)
        end
    end
end
function AP:showMessages(pos, color)
    if not pos then
        pos = Vector(self.HUD_OFFSET, 260 - self.HUD_OFFSET)
    end
    for i = 1, 3 do
        if self.MESSAGE_QUEUE[i] and self.MESSAGE_QUEUE[i].timer > 0 then
            local posX = pos.X
            for _, v in ipairs(self.MESSAGE_QUEUE[i].parts) do
                if not v.width then
                    v.width = Isaac.GetTextWidth(v.msg)
                end
                Isaac.RenderScaledText(v.msg, posX, pos.Y - 10 * (4 - i) * self.INFO_TEXT_SCALE, self.INFO_TEXT_SCALE,
                    self.INFO_TEXT_SCALE, v.color.R, v.color.G, v.color.B, v.color.A)
                posX = posX + v.width * self.INFO_TEXT_SCALE
            end
            self.MESSAGE_QUEUE[i].timer = self.MESSAGE_QUEUE[i].timer - 1
        end
    end
    self:proceedMessageQueue()
end
function AP:showDebugInfo()
    local lineHeight = 10 * self.INFO_TEXT_SCALE;
    Isaac.RenderScaledText("CURRENT_TYPING_STRING: " .. self.AP_MCM.CURRENT_TYPING_STRING, 100, 0, self.INFO_TEXT_SCALE,
        self.INFO_TEXT_SCALE, 255, 0, 0, 1)
    local unlocktext = "false"
    if self.AP_MCM.UNLOCK_TYPING then
        unlocktext = "true"
    end
    Isaac.RenderScaledText("UNLOCK_TYPING: " .. unlocktext, 100, lineHeight, self.INFO_TEXT_SCALE, self.INFO_TEXT_SCALE,
        255, 0, 0, 1)
    local toggletext = "false"
    if self.AP_MCM.TOGGLE_LOWERCASE then
        toggletext = "true"
    end
    Isaac.RenderScaledText("TOGGLE_LOWERCASE: " .. toggletext, 100, lineHeight * 2, self.INFO_TEXT_SCALE,
        self.INFO_TEXT_SCALE, 255, 0, 0, 1)
    Isaac.RenderScaledText("WAIT_TYPING_ENTER_EXIT: " .. self.AP_MCM.WAIT_TYPING_ENTER_EXIT, 100, lineHeight * 3,
        self.INFO_TEXT_SCALE, self.INFO_TEXT_SCALE, 255, 0, 0, 1)
    Isaac.RenderScaledText("RECONNECT_TRIES: " .. self.RECONNECT_TRIES, 100, lineHeight * 4, self.INFO_TEXT_SCALE,
        self.INFO_TEXT_SCALE, 255, 0, 0, 1)
    Isaac.RenderScaledText("#TRAP_QUEUE: " .. #self.TRAP_QUEUE, 100, lineHeight * 5, self.INFO_TEXT_SCALE,
        self.INFO_TEXT_SCALE, 255, 0, 0, 1)
    Isaac.RenderScaledText("TRAP_QUEUE_TIMER: " .. self.TRAP_QUEUE_TIMER, 100, lineHeight * 6, self.INFO_TEXT_SCALE,
        self.INFO_TEXT_SCALE, 255, 0, 0, 1)
    Isaac.RenderScaledText("PICKUP_TIMER: " .. self.PICKUP_TIMER, 100, lineHeight * 7, self.INFO_TEXT_SCALE,
        self.INFO_TEXT_SCALE, 255, 0, 0, 1)
end
-- END AP message printing

-- mod callback util funcs
function AP:showPermanentMessage()
    local state = self:getAPState()
    if state == nil then
        state = "! UNKNOWN STATE !"
    end
    local text = "AP: " .. state
    if state == AP.STATES[0] then
        Isaac.RenderScaledText(text, self.HUD_OFFSET, 260 - 10 * 5 * self.INFO_TEXT_SCALE - self.HUD_OFFSET,
            self.INFO_TEXT_SCALE, self.INFO_TEXT_SCALE, 255, 0, 0, 1)
    elseif state == AP.STATES[4] then
        Isaac.RenderScaledText(text, self.HUD_OFFSET, 260 - 10 * 5 * self.INFO_TEXT_SCALE - self.HUD_OFFSET,
            self.INFO_TEXT_SCALE, self.INFO_TEXT_SCALE, 0, 255, 0, 1)
        if self.CONNECTION_INFO and self.SLOT_DATA then
            local goal = self.SLOT_DATA.goal
            local text2 = string.format("%s/%s checked (need %s); next check: %s/%s; goal: %s",
                #self.AP_CLIENT.checked_locations, self.SLOT_DATA.totalLocations, self.SLOT_DATA.requiredLocations,
                self.CUR_ITEM_STEP_VAL, self.SLOT_DATA.itemPickupStep, self:goalIdToName(goal))
            local player = Isaac.GetPlayer()
            local playerType = player:GetPlayerType()
            local playerName = player:GetName()
            if goal == 16 then
                local reqNoteAmount = tonumber(self.SLOT_DATA.fullNoteAmount)
                text2 = text2 .. " (" .. self.COMPLETED_NOTES .. "/" .. reqNoteAmount .. ";" .. playerName .. ":" ..
                            self:countNoteMarksForPlayerType(playerType) .. "/" .. tablelength(self.NOTE_TYPES) .. ")"
            elseif goal == 17 then
                local reqNoteMarks = tonumber(self.SLOT_DATA.noteMarksAmount)
                text2 = text2 .. " (" .. self.COMPLETED_NOTE_MARKS .. "/" .. reqNoteMarks .. ";" .. playerName .. ":" ..
                            self:countNoteMarksForPlayerType(playerType) .. "/" .. tablelength(self.NOTE_TYPES) .. ")"
            end
            Isaac.RenderScaledText(text2, self.HUD_OFFSET, 260 - 10 * 4 * self.INFO_TEXT_SCALE - self.HUD_OFFSET,
                self.INFO_TEXT_SCALE, self.INFO_TEXT_SCALE, 255, 255, 255, 1)
        end
    else
        Isaac.RenderScaledText(text, self.HUD_OFFSET, 260 - 10 * 5 * self.INFO_TEXT_SCALE - self.HUD_OFFSET,
            self.INFO_TEXT_SCALE, self.INFO_TEXT_SCALE, 255, 255, 0, 1)
    end
end
function AP:proceedPickupTimer()
    if self.PICKUP_TIMER > 0 then
        self.PICKUP_TIMER = self.PICKUP_TIMER - 1
    end
end

function AP:goalIdToName(goal)
    return self.GOAL_NAMES[goal]
end
function AP:isGoalBoss(type)
    for _, v in pairs(self.GOAL_BOSSES) do
        for i, v2 in ipairs(v) do
            if v2 == type then
                return true
            end
        end
    end
    return false
end
function AP:saveConnectionInfo()
    local modData = {}
    if self.MOD_REF:HasData() then
        modData = json.decode(self.MOD_REF:LoadData())
    end
    modData.HOST_ADDRESS = self.HOST_ADDRESS
    modData.HOST_PORT = self.HOST_PORT
    modData.SLOT_NAME = self.SLOT_NAME
    modData.PASSWORD = self.PASSWORD
    self.MOD_REF:SaveData(json.encode(modData))
end
function AP:loadConnectionInfo()
    if self.MOD_REF:HasData() then
        local modData = json.decode(self.MOD_REF:LoadData())
        if modData ~= nil and modData.HOST_ADDRESS ~= nil and modData.HOST_PORT ~= nil and modData.PASSWORD ~= nil and
            modData.SLOT_NAME ~= nil then
            self.HOST_ADDRESS = modData.HOST_ADDRESS
            self.HOST_PORT = modData.HOST_PORT
            self.SLOT_NAME = modData.SLOT_NAME
            self.PASSWORD = modData.PASSWORD
        end
    end
end
function AP:saveSettings()
    local modData = {}
    if self.MOD_REF:HasData() then
        modData = json.decode(self.MOD_REF:LoadData())
    end
    modData.DEBUG_MODE = self.DEBUG_MODE
    modData.INFO_TEXT_SCALE = self.INFO_TEXT_SCALE
    modData.HUD_OFFSET = self.HUD_OFFSET
    modData.SHOULD_AUTO_CONNECT = self.SHOULD_AUTO_CONNECT
    self.MOD_REF:SaveData(json.encode(modData))
end
function AP:loadSettings()
    if self.MOD_REF:HasData() then
        local modData = json.decode(self.MOD_REF:LoadData())
        if modData ~= nil then
            if modData.DEBUG_MODE ~= nil then
                self.DEBUG_MODE = modData.DEBUG_MODE
            end
            if modData.INFO_TEXT_SCALE ~= nil then
                self.INFO_TEXT_SCALE = modData.INFO_TEXT_SCALE
            end
            if modData.HUD_OFFSET ~= nil then
                self.HUD_OFFSET = modData.HUD_OFFSET
            end
            if modData.SHOULD_AUTO_CONNECT ~= nil then
                self.SHOULD_AUTO_CONNECT = modData.SHOULD_AUTO_CONNECT
            end
        end
    end
end
function AP:loadOtherData(seed)
    if self.MOD_REF:HasData() then
        local modData = json.decode(self.MOD_REF:LoadData())
        dbg_log("loaded seed: " .. tostring(modData.SAVED_SEED))
        if modData ~= nil and modData.SAVED_SEED ~= nil and modData.SAVED_ITEM_INDEX ~= nil and
            modData.CUR_ITEM_STEP_VAL ~= nil and seed == modData.SAVED_SEED then
            self.LAST_RECEIVED_ITEM_INDEX = modData.SAVED_ITEM_INDEX
            self.CUR_ITEM_STEP_VAL = modData.CUR_ITEM_STEP_VAL
        else
            return false
        end
    end
    return true
end
function AP:saveOtherData(seed)
    dbg_log("saving seed: " .. tostring(seed))
    local modData = {}
    if self.MOD_REF:HasData() then
        modData = json.decode(self.MOD_REF:LoadData())
    end
    modData.SAVED_ITEM_INDEX = self.LAST_RECEIVED_ITEM_INDEX
    modData.SAVED_SEED = seed
    modData.CUR_ITEM_STEP_VAL = self.CUR_ITEM_STEP_VAL
    self.MOD_REF:SaveData(json.encode(modData))
end

AP()

